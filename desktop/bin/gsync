#!/bin/bash

################################################################################
#                                 FILE INFO
# Sync git repositories (supports both worktree and normal repos)
#
# Configuration format:
#   "path"          - sync using auto-detected default branch
#   "path:branch"   - sync using specified branch
#   "path:default"  - explicitly use auto-detected default branch
################################################################################

set -Eeuo pipefail

cd "$(dirname "$0")" || exit 1
LIBS_DIR=${LIBS_DIR:="$HOME/lib"}
. "$LIBS_DIR/lib_utils.sh"
. "$LIBS_DIR/lib_gsync.sh"

# Configuration
COMMIT_MSG="auto-update"

# Sync a single repository
sync_repo() {
    local repo_path="$1"
    local configured_branch="$2"

    # Validate repository exists
    if [ ! -d "$repo_path" ]; then
        log ERRO " Repository not found: $repo_path"
        return 1
    fi

    cd "$repo_path" || {
        log ERRO "Cannot access: $repo_path"
        return 1
    }

    log INFO "Syncing: $repo_path"

    # Determine target branch
    local target_branch
    if [ -z "$configured_branch" ] || [ "$configured_branch" = "default" ]; then
        target_branch=$(get_default_branch)
        log INFO "Branch: $target_branch (default)"
    else
        target_branch="$configured_branch"
        log INFO "Branch: $target_branch (configured)"
    fi

    # Verify we're on the target branch
    local current_branch=$(get_current_branch)
    if [ "$current_branch" != "$target_branch" ]; then
        log WARN "On '$current_branch', expected '$target_branch' - skipping"
        return 0
    fi

    # Sync repository
    log INFO "  Fetching updates..."
    git fetch origin "$target_branch" 2>&1 || {
        log ERRO "Fetch failed"
        return 1
    }

    log INFO "  Pulling changes..."
    git pull origin "$target_branch" 2>&1 || {
        log ERRO "Pull failed"
        return 1
    }

    # run pre-commit
    if [ -f ".pre-commit-config.yaml" ]; then
        uvx pre-commit run --show-diff-on-failure --color=always --all-files
    fi
    # Stage all changes
    git add .

    # Commit and push if there are changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        log INFO "  Committing changes..."
        local commit_output
        if ! commit_output=$(git commit -m "$COMMIT_MSG" 2>&1); then
            log ERRO "  Commit failed"
            log DEBG "$commit_output"
            git reset HEAD . 2>/dev/null || true  # Cleanup: unstage changes
            return 1
        fi

        log INFO "  Pushing changes..."
        local push_output
        if ! push_output=$(git push origin "$target_branch" 2>&1); then
            log ERRO "  Push failed"
            log DEBG "$push_output"
            return 1
        fi
        log INFO "  ✓ Synced with changes"
    else
        log INFO "  ✓ Already up to date"
    fi

    return 0
}

# Main execution
main() {

    local failed_repos=()
    local total=0
    local success=0

    # Process each repository
    for repo_config in "${REPOS[@]}"; do
        total=$((total + 1))

        # Parse configuration: "path" or "path:branch"
        local repo_path="${repo_config%%:*}"
        local branch=""
        [[ "$repo_config" == *:* ]] && branch="${repo_config#*:}"

        # Expand variables in path
        repo_path=$(eval echo "$repo_path")

        # Sync repository
        if sync_repo "$repo_path" "$branch"; then
            success=$((success + 1))
        else
            failed_repos+=("$repo_path")
        fi

        echo
    done

    # Report results
    log INFO "Completed: $success/$total repositories"

    if [ ${#failed_repos[@]} -gt 0 ]; then
        log ERRO "${failed_repos[*]}"
        update_status 1 "Failed: ${failed_repos[*]}"
        exit 1
    else
        log INFO "All repositories synced successfully"
        update_status 0 "OK"
        exit 0
    fi
}

main
